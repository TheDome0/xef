Module "Whitespace"
Uses
	"Avail"
Names
	/* Special atoms (for significant whitespace support). */
	"indent id",

	/* Indentation management. */
	"Require:_agrees with_",
	"Require:_nests beneath_"
Body

/**
 * Herein is support for correct and ergonomoic treatment of whitespace in a
 * whitespace sensitive language. Based loosely on YAML, the Xef prompting
 * language (1) uses line breaks both to continue and terminate expressions and
 * (2) uses indentation to establish nesting.
 *
 * @module "Whitespace"
 */

////////////////////////////////////////////////////////////////////////////////
//                               Special atoms.                               //
////////////////////////////////////////////////////////////////////////////////

/**
 * The special {@type "atom"} that represents a semantic indent in the Xef
 * prompting language. The lexeme itself may be any combination of horizontal
 * tabulation (U+0009) and space (U+0020), though sane usage will exclusive
 * utilize one or the other.
 *
 * @method "indent id"
 * @returns "atom"
 */
Public "indent id" is a new atom;

////////////////////////////////////////////////////////////////////////////////
//                          Indentation management.                           //
////////////////////////////////////////////////////////////////////////////////

/**
 * Escape the horizontal tabulations (U+0009) and spaces (U+0020) in the
 * argument, replacing the former with bottom square bracket [⎵] (U+23B5) and
 * the latter with rightwards arrow to bar [⇥] (U+21E5).
 *
 * @method "“_”(escaped)"
 * @param "s" "string"
 *   Theoretically, an arbitrary string; practically, the lexeme of some
 *   indentation produced by the {@lexer "significant whitespace lexer"}).
 * @returns "string"
 *   An escaped version of the argument.
 */
Private method "“_”(escaped)" is
[
	s : string
|
	c ∈ s → {"\t" → "⇥", " " → "⎵"}[c] else [c]
];

/**
 * Strengthen the return type of {@method "“_”(escaped)"} to preserve the
 * length of the argument, which is invariant under the transformation.
 *
 * @method "“_”(escaped)"
 * @restricts "{string}ᵀ"
 */
Semantic restriction "“_”(escaped)" is
[
	s : {string}ᵀ
|
	<<>, character… | ||s||>
];

/**
 * Reject the current parse unless the {@param "newIndent" proposed indent}
 * agrees exactly with the {@param "establishedIndent" established indent}.
 * Must only be called from the dynamic scope of a macro.
 *
 * @method "Require:_nests beneath_"
 * @param "newIndent" "literal phrase ⇒ literal token ⇒ {indent id}ᵀ"
 *   The new indent {@type "token"}, wrapped in a {@type "literal phrase"} by
 *   {@code "…#"}.
 * @param "establishedIndent" "literal phrase ⇒ literal token ⇒ {indent id}ᵀ"
 *   The established indent {@type "token"}, wrapped in a
 *   {@type "literal phrase"} by {@code "…#"}.
 * @returns "⊤"
 */
Public method "Require:_agrees with_" is
[
	newIndent : literal phrase ⇒ literal token ⇒ {indent id}ᵀ,
	establishedIndent : literal phrase ⇒ literal token ⇒ {indent id}ᵀ
|
	newLexeme ::= newIndent's token's lexeme;
	establishedLexeme ::= establishedIndent's token's lexeme;
	Unless establishedLexeme = newLexeme then
	[
		Reject parse, expected:
			format
				"indent to agree exactly with established indent \
				\|(but “①” differs from “②”)"
			with
				“newLexeme” (escaped),
				“establishedLexeme” (escaped)
	];
]
styled by assertion styler;

/**
 * Reject the current parse unless {@param "subexpressionIndent"} is a valid
 * extension of {@param "expressionIndent"}. Must only be called from the
 * dynamic scope of a macro.
 *
 * @method "Require:_nests beneath_"
 * @param "subexpressionIndent" "literal token ⇒ {indent id}ᵀ"
 *   The indent {@type "token"} for the subexpression, wrapped in a
 *   {@type "literal phrase"} by {@code "…#"}..
 * @param "expressionIndent" "literal token ⇒ {indent id}ᵀ"
 *   The indent {@type "token"} for the subexpression, wrapped in a
 *   {@type "literal phrase"} by {@code "…#"}.
 * @returns "⊤"
 */
Public method "Require:_nests beneath_" is
[
	subexpressionIndent : literal phrase ⇒ literal token ⇒ {indent id}ᵀ,
	expressionIndent : literal phrase ⇒ literal token ⇒ {indent id}ᵀ
|
	subexpressionLexeme ::= subexpressionIndent's token's lexeme;
	expressionLexeme ::= expressionIndent's token's lexeme;
	Unless subexpressionLexeme starts with expressionLexeme then
	[
		Reject parse, expected:
			format
				"indent of subexpression to extend established indent \
				\|(but “①” does not lead with “②”)"
			with
				“subexpressionLexeme” (escaped),
				“expressionLexeme” (escaped)
	];
	Unless |subexpressionLexeme| > |expressionLexeme| then
	[
		Reject parse, expected: "indent of subexpression to increase indent level"
	];
]
styled by assertion styler;
